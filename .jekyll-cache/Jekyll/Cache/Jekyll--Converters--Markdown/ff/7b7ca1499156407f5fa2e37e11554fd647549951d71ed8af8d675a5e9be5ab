I"B<h2 id="들어가기-전에">들어가기 전에</h2>
<p>  현대의 컴퓨터 환경에서 워너크라이 랜섬웨어, Windows Spooler 취약점 공격 등 다양한 보안 사고가 끊임없이 발생하고 있으며 그로 인한 피해는 매우 심각한 수준이다. 특히 이번 포스트에서 다룰 Heartbleed 공격은 10여년 전 발견됐지만 공격 대상이 된 시스템에서 민감한 정보를 관리자가 인지하지 못하는 사이에 외부로 유출시킬 수 있다는 점에서 치명적인 위협이라고 생각한다.<br /><br />
  Heartbleed 공격은 TLS Record 프로토콜의 확장 기능인 Heartbeat의 구현 오류에서 비롯된 보안 취약점을 이용한 공격으로 주로 서버의 메모리를 비정상적을 읽어오는 방식으로 이루어졌다. 이로 인해 비밀키, 사용자 인증 정보, 민감한 데이터, 보안 메커니즘 우회에 사용될 수 있는 내부 정보 등과 같은 중요한 데이터가 유출될 수 있었다.<br /><br />
  본 포스트에서는 이러한 Heartbleed 공격의 심각성을 인식하고, 이를 보다 명확히 이해하기 위해 Heartbeat 프로토콜의 도입 배경과 요구사항을 기술한 후, 취약점이 존재하는 코드를 분석하여 구체적인 공격 메커니즘에 대한 이해를 돕고자한다. 또한 실제 피해 사례를 소개하고, 대응 방안에 대해 여러 자료들을 바탕으로 다양한 관점에서 서술하고자 한다.
<br /><br /></p>

<hr />

<h2 id="1-heartbeat-메시지의-도입-배경">1. HEARTBEAT 메시지의 도입 배경</h2>
<p>  Heartbeat 메시지는 SSL(Secure Sockets Layer) 위에서 동작하는 확장 기능으로 연결 상태를 주기적으로 확인하기 위해 도입되었다.<br />
<br />  TLS는 TCP 기반 SSL이 적용된 프로토콜로, TCP는 지속적인 데이터 전송 없이 연결 상태(Connection Alive)를 유지할 수 있는 기능이 반드시 제공되지 않는 상황에서 제안되었다. DTLS는 UDP 기반 SSL이 적용된 프로토콜로, 데이터그램(Datagram)을 안전하게 전송하기 위해 설계되었다. 그러나 TLS와 달리 세션 관리 기능이 없어, 상대방이 통신 가능한 상태인지 확인하는 유일한 방법은 재협상(renegotiation) 뿐이었다. 이러한 재협상은 Handshake 과정을 다시 수행해야 하므로, 특히 단방향 트래픽을 사용하는 애플리케이션에서는 비효율적인 측면이 있다.<br />
<br />  이러한 한계를 해결하기 위해 2010년 6월 18일 <a href="https://datatracker.ietf.org/doc/html/draft-seggelmann-tls-dtls-heartbeat-00">IETF의 초안 문서</a>에서 Heartbeat 메시지 개념이 제안되었다.
이후 해당 개념은 <a href="https://datatracker.ietf.org/doc/html/rfc6520">RFC 6520</a> (Transport Layer Security(TLS) and Datagram Transport Layer Security(DTLS) Heartbeat Extension)으로 발전했으며, OpenSSL 측에서는 2012년 03월 14일에 공개된 <a href="https://github.com/openssl/openssl/releases/tag/OpenSSL_1_0_1">OpenSSL 1.0.1</a> 버전에서 처음으로 도입하였다.
<br /><br /></p>

<hr />

<h2 id="2-heartbeat-protocol-주요-요구사항">2. HEARTBEAT PROTOCOL 주요 요구사항</h2>
<p><img src="/assets/img/blog/heartbeat-diagram0.png" alt="Heartbeat Diagram" style="max-width: 100%; border-radius: 12px;" />
<br /></p>
<ul>
  <li>Heartbeat Protocol은 HeartbeatRequest, HeartbeatResponse 두 가지 메시지 타입으로 구성된다.</li>
  <li>HeartbeatRequest 메시지는 연결이 유지되고 있는 동안 언제든지 도착할 수 있다.</li>
  <li>HeartbeatRequest 메시지를 수신하면, 상응하는 HeartbeatResponse 메시지로 응답해야 한다.</li>
  <li>HeartbeatRequest 수신 측은 동일한 페이로드를 포함하는 HeartbeatResponse 메시지를 반드시 전송해야 한다.</li>
  <li>수신된 Heartbeat 메시지의 페이로드 길이 필드 값이 너무 큰 경우 조용히 폐기되어야 한다.</li>
  <li>수신한 HeartbeatResponse 메시지가 HeartbeatRequest의 페이로드를 포함하지 않은 경우 조용히 폐기되어야 한다.</li>
  <li>Heartbeat Protocol 메시지는 Heartbeat 메시지 타입 필드, unsigned int16(부호 없는 16bit 정수)를 범위로 하는 페이로드 길이 필드, 페이로드 필드, 패딩 필드로 구성된다.<br />
<br /><br /></li>
</ul>

<hr />

<h2 id="3-정상적인-heartbeat-message-동작-과정">3. 정상적인 Heartbeat Message 동작 과정</h2>
<p><img src="/assets/img/blog/heartbeat-diagram1.png" alt="Heartbeat Diagram" style="max-width: 100%; border-radius: 12px;" /><br />
<br />
① 클라이언트와 서버가 암호화 통신을 위해 SSL/TLS Handshake를 한다.<br />
② 일정 주기로 클라이언트에서 서버로 HeartbeatRequest 메시지를 송신한다.<br />
③ 서버에서 HeartbeatRequest 메시지를 수신 후 버퍼에 저장한다.<br />
④ 버퍼에 저장한 HeartbeatRequest 정보를 바탕으로 HeartbeatResponse 메시지를 구성하여 클라이언트에 송신한다.<br />
⑤ 클라이언트에서 HeartbeatResponse 메시지를 수신하여 연결 상태를 확인한다.<br />
⑥ 이 과정을 반복한다.
<br /><br /></p>

<hr />

<h2 id="4-취약점-코드">4. 취약점 코드</h2>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">int</span>
	<span class="n">tls1_process_heartbeat</span><span class="p">(</span><span class="no">SSL</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
		<span class="p">{</span>
		<span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="nb">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s3</span><span class="o">-&gt;</span><span class="n">rrec</span><span class="p">.</span><span class="nf">data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">pl</span><span class="p">;</span>
		<span class="n">unsigned</span> <span class="n">short</span> <span class="n">hbtype</span><span class="p">;</span>
		<span class="n">unsigned</span> <span class="n">int</span> <span class="n">payload</span><span class="p">;</span>
		<span class="n">unsigned</span> <span class="n">int</span> <span class="n">padding</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> 

		<span class="n">hbtype</span> <span class="o">=</span> <span class="o">*</span><span class="nb">p</span><span class="o">++</span><span class="p">;</span>
		<span class="n">n2s</span><span class="p">(</span><span class="nb">p</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
		<span class="n">pl</span> <span class="o">=</span> <span class="nb">p</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>		<span class="k">if</span> <span class="p">(</span><span class="n">hbtype</span> <span class="o">==</span> <span class="no">TLS1_HB_REQUEST</span><span class="p">)</span>
			<span class="p">{</span>
			<span class="n">unsigned</span> <span class="n">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
			<span class="n">int</span> <span class="n">r</span><span class="p">;</span>

			<span class="n">buffer</span> <span class="o">=</span> <span class="no">OPENSSL_malloc</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">payload</span> <span class="o">+</span> <span class="n">padding</span><span class="p">);</span>
			<span class="n">bp</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">;</span>
			

			<span class="o">*</span><span class="n">bp</span><span class="o">++</span> <span class="o">=</span> <span class="no">TLS1_HB_RESPONSE</span><span class="p">;</span>
			<span class="n">s2n</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">pl</span><span class="p">,</span> <span class="n">payload</span><span class="p">);</span>
			<span class="n">bp</span> <span class="o">+=</span> <span class="n">payload</span><span class="p">;</span>

			<span class="n">r</span> <span class="o">=</span> <span class="n">ssl3_write_bytes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="no">TLS1_RT_HEARTBEAT</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">payload</span> <span class="o">+</span> <span class="n">padding</span><span class="p">);</span>

		<span class="o">...</span> <span class="err">이하</span> <span class="err">생략</span>

	<span class="p">}</span>
</code></pre></div></div>
<div style="text-align: center; margin-top: -10px; padding-bottom: 1.2em;">
출처: OpenSSL GitHub - OpenSSL 1.0.1 release
</div>

<hr />

<h6 id="참조">참조</h6>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">1</span>	<span class="n">define</span> <span class="n">n2s</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>  <span class="p">((</span><span class="n">s</span><span class="o">=</span><span class="p">(((</span><span class="n">unsigned</span> <span class="n">int</span><span class="p">)(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">&lt;&lt;</span> <span class="mi">8</span> <span class="o">|</span> <span class="p">\</span>
			<span class="p">(((</span><span class="n">unsigned</span> <span class="n">int</span><span class="p">)(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]))))),</span> <span class="n">c</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span>

<span class="mi">2</span>	<span class="n">define</span> <span class="n">s2n</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">c</span><span class="p">)</span>  <span class="p">((</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">char</span><span class="p">)(((</span><span class="n">s</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">),</span> <span class="p">\</span>
			<span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">unsigned</span> <span class="n">char</span><span class="p">)(((</span><span class="n">s</span><span class="p">))</span><span class="o">&amp;</span><span class="mh">0xff</span><span class="p">)),</span> <span class="n">c</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<h2 id="5-취약점을-이용한-공격-과정">5. 취약점을 이용한 공격 과정</h2>
<p><img src="/assets/img/blog/heartbeat-diagram2.png" alt="Heartbeat Diagram" style="max-width: 100%; border-radius: 12px;" /><br />
<br />
① 클라이언트와 서버가 암호화 통신을 위해 SSL/TLS Handshake를 한다.<br />
② 클라이언트(공격자)는 HeartbeatRequest 메시지의 Payload Length 값을 조작하고 Payload 내용을 최대한 짧은 데이터로 조작하여 송신한다.<br />
③ 서버에서 어떠한 인증 없이 HeartbeatRequest 메시지를 수신 후 버퍼에 저장한다.<br />
④ 버퍼에 저장된 payload부터 Payload Length 값을 길이로 한 새로운 payload를 HeartbeatResponse 메시지에 복사하여 클라이언트(공격자)에 송신한다.<br />
⑤ 클라이언트에서 수신한 메시지에서 원 페이로드를 제외한 나머지 데이터를 조합하여 유의미한 정보를 추출한다.<br />
⑥ 이 과정을 수차례 반복한다.
<br /><br /></p>

<hr />

<h2 id="6-피해사례">6. 피해사례</h2>
<ul>
  <li>캐나다 국세청(CRA): 900명의 사회보장번호 유출, 캐나다 국세청 5일간 온라인 서비스 중지, 사회보장 번호 재발급</li>
  <li>미국: Community Health Systems(미국의 영리병원체인 중 2번째 규모)의 450만 명의 환자기록 유출 당함</li>
  <li>영국 Mumsnet: 150만 명 회원정보 유출 당함</li>
  <li>OKCupid: 사용자의 로그인 정보와 메시지 내용(채팅 내역, 성적 취향 등) 노출<br />
<br />
  위에서 기술한 사례들처럼, 해당 취약점은 광범위하게 영향을 미쳤다. 또한 취약점이 공개되기 전까지는 Heartbeat 메시지를 IDS/IPS에서 로그에 저장하는 것이 기술적으로 가능했음에도 불구하고, 대부분의 기관은 그 필요성을 느끼지 못해 기록하지 않았다. 이로 인해 특정 기관의 온라인 서비스가 취약한 지는 알 수 있었지만 공격이 실제로 발생했는지, 발생했다면 어느 범위까지 피해가 확산되었는지를 정확히 파악할 수 없게되었다. 
<br /><br /></li>
</ul>

<hr />

<h2 id="7-대응-방안">7. 대응 방안</h2>

<p><strong>7.1  취약점 발견 전 예방조치</strong><br />
<em>개발 측 예방조치</em><br />
:: 시큐어코딩 준수<br />
:: 프로토콜 표준문서와 구현코드 비교검증<br />
:: 퍼징(Fuzzing) 테스트</p>

<p><em>제도적 대응방안</em><br />
:: 소스코드 외부 감사<br />
:: 버그바운티 활성화<br />
<br /><br />
<strong>7.2 ZERO-DAY ~ ONE-DAY 대응방안</strong><br />
<em>취약점 발견자 대응방안</em><br />
:: Zero-Day 공격 방지 및 완화를 위해 해당 취약점을 유관기관에만 알려 보안 패치를 준비할 시간 확보<br />
:: PoC(Proof of Concept) 공유 보류</p>

<p><em>Server 측 대응방안</em><br />
:: IDS/IPS를 통한 이상 트래픽 탐지 및 차단(Heartbeat Request 메시지 중 Payload Length 값이 비정상적으로 크거나 payload 길이와 같지 않은 트래픽 분석)<br />
:: 서버에서의 Heartbeat 기능 비활성화(-DOPENSSL_NO_HEARTBEATS 옵션을 켜고 OpenSSL을 컴파일 후 적용)<br />
:: 소스코드 변경 후 적용(Payload Length와 payload 길이 비교 검증 코드 추가)<br />
:: 서버 인증서 재발급(서버측 SSL Secret Key 유출 가능성 존재)<br />
:: PFS(Perfect Forward Secrecy)를 사용하여 각 세션마다 임시 키 사용</p>

<p><em>Client 측 대응방안</em><br />
:: 비밀번호 재설정(취약한 포탈, 유사한 비밀번호 쓰는 포탈)<br />
:: MFA(Multi Factor Authentication) 사용<br />
<br /><br />
<strong>7.3 ONE-DAY 이후 대응방안</strong><br />
<em>보안 패치 적용 가능한 환경</em><br />
:: OpenSSL 보안 패치 적용 버전으로 업그레이드</p>

<p><em>보안 패치 적용이 어려운 환경</em><br />
:: IDS/IPS 룰 추가 및 모니터링<br />
:: 샌드박스 환경에서 테스트 후 보안 패치 적용<br />
<br /><br /></p>

<hr />

<h2 id="8-결론">8. 결론</h2>
<p>  OpenSSL Heartbeat 취약점 사태는 개발 단계의 실수가 어떻게 전 세계적인 보안 이슈로 연결될 수 있는지를 보여주는 대표적인 사례다.
<br /><br />
  해당 취약점은 Heartbeat 메시지를 처리하는 과정에서 Payload Length 값이 실제 Payload 보다 클 경우에도 그대로 메모리를 복사하여 전달함으로써 발생했다. 이는 클라이언트 입력값 미검증, 경계선 검사, 그리고 프로토콜 요구 사항을 구현하지 않았다.
<br /><br />
  이러한 구현상의 결함은 캐나다, 미국, 영국 등 여러 국가의 공공기관과 기업에서 사회보장번호, 의료정보, 계정, 세션키 등의 민감한 정보 유출로 이어졌다. 또한, 당시 대부분의 IDS/IPS 시스템은 Heartbeat 메시지를 정상적인 TLS 트래픽으로 처리해 로그를 기록하지 않았기 때문에, 공격의 발생 여부나 피해 범위를 정확히 파악하는 것조차 불가능한 상황이 되게 하였다.
<br /><br />
  위에서 기술한 3가지 원인은 단 몇 줄의 코드로 해결 가능한 부분이다. 그럼에도 불구하고 이러한 사태가 발생했다는 것은 보안이 단순한 기능의 부가 요소가 아니라 설계와 개발 단계에서부터 내재화되어야 할 필수 요소임을 시사한다.</p>

<hr />

:ET