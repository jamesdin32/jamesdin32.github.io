I"&<h2 id="들어가기-앞서">들어가기 앞서</h2>
<p><strong>프로그래머 관점에서</strong><br />
  현대의 애플리케이션 개발에서 소켓 통신을 이해하는 것은 선택이 아닌 필수가 되었다. 채팅 앱, 온라인 게임, IoT 디바이스, 금융 서비스 등 우리가 일상적으로 접하는 대부분의 서비스가 클라이언트-서버 구조로 동작하며, 이 모든 통신의 근간에는 소켓이 자리하고 있다. 많은 웹 개발자들이 HTTP API만으로도 충분하다고 생각하지만, HTTP 역시 결국 TCP 소켓 위에서 구현된 프로토콜이다. 진정한 네트워크 프로그래밍 역량을 갖추려면 이러한 저수준 동작 원리를 이해해야 한다. 특히 실시간 스트리밍, 게임 서버, 보안이 중요한 시스템을 개발할 때는 HTTP로는 한계가 있어 TCP나 UDP 소켓을 직접 다루며 프로토콜을 설계해야 한다. 더 중요한 것은 디버깅 능력의 차이다. 서버와의 통신에 문제가 생겼을 때, 소켓을 모르면 클라이언트 코드만 뒤적거리게 된다. 하지만 소켓을 이해하고 있다면 패킷이 제대로 전송되었는지, 서버 응답이 왔는지, 어느 구간에서 막혔는지 체계적으로 추적할 수 있다.</p>

<p><strong>네트워크 엔지니어 관점에서</strong><br />
  네트워크 엔지니어에게 소켓은 애플리케이션과 네트워크 인프라를 연결하는 핵심 고리다. 모든 네트워크 트래픽은 결국 애플리케이션이 소켓을 통해 데이터를 전송한 결과물이다. 이를 이해하지 못하면 “왜 이 포트가 열려야 하는지”, “왜 특정 연결이 실패하는지”에 대한 근본적인 설명이 불가능하다. 방화벽과 보안 정책을 설정할 때도 소켓 지식은 필수다. 단순히 포트 번호만 보고 정책을 만들면 서비스가 제대로 작동하지 않거나, 반대로 보안 취약점이 생길 수 있다. 애플리케이션이 어떤 방식으로 소켓 통신을 하는지 알아야 적절한 접근 제어 정책을 수립할 수 있다. 패킷 분석 도구를 활용할 때도 소켓 지식이 빛을 발한다. Wireshark나 tcpdump로 트래픽을 분석할 때, TCP의 3-way handshake나 연결 상태 변화를 이해하고 있어야 패킷의 흐름을 정확히 해석할 수 있다. 이런 지식 없이는 화면에 나타나는 숫자들이 그저 의미 없는 데이터일 뿐이다. 무엇보다 소켓을 이해하면 문제 발생 시 애플리케이션 문제인지 네트워크 인프라 문제인지 명확히 구분할 수 있다. 이는 개발팀과 인프라팀 간의 효율적인 협업을 가능하게 하며, 문제 해결 시간을 크게 단축시킨다.
<br /><br /></p>

<hr />

<h2 id="소켓이란">소켓이란?</h2>
<p>  서로 떨어진 두 대의 컴퓨터 사이에서 TCP/IP 네트워크를 통해 상호 통신이 가능하도록 운영체제에서 해당 자원을 할당하고, 처리해 주는 방식을 의미한다. 다시 말해 컴퓨터 상호간에 데이터를 주고받기 위한 프로세스 처리 방식을 소켓이라고 한다. 소켓은 1982년 BSD 유닉스 커널에서 <strong>C 언어</strong>를 통해 구현됐고, 이에 기반해 1986년 <strong>TCP/IP 소켓 방식</strong>을 표준으로 확립했다. 오늘날 사용하는 소켓은 특별한 언급이 없는 한 C 언어로 구현한 BSD 유닉스 커널에 기반한 TCP/IP 소켓 방식을 의미한다.<br />
<br />
  소켓 통신은 <strong>클라이언트(Client) - 서버(Server) 구조</strong>를 전제로 한다. 서버와 클라이언트는 서비스를 기준으로 구분하는데, 서버는 서비스를 제공하는 컴퓨터를 의미하고, 클라이언트는 서비스를 요청하는 컴퓨터를 의미한다.
<br /><br /></p>

<hr />

<h2 id="동작-흐름-요약">동작 흐름 요약</h2>
<p>서버는 소켓을 생성한다.                      socket 함수 호출<br />
IP 주소와 Port 번호를 할당한다.       bind 함수 호출<br />
연결요청 가능 상태로 변경한다.         listen 함수 호출<br />
서버가 요청을 수락합니다.                  accept 함수 호출<br />
서로 데이터를 주고받습니다.<br />
통신이 끝나면 소켓을 종료(Close) 합니다.
<br /><br /></p>

<hr />

<h2 id="python-소켓">python 소켓</h2>
<!-- 소켓 라이브러리 불러오기 -->
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">socket</span>
</code></pre></div></div>
<p>  C에 포팅된 Python Socket Library를 불러온다.<br />
<br />
<!-- 소켓 객체 생성 --></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sock</span> <span class="o">=</span> <span class="n">socket</span><span class="p">.</span><span class="n">socket</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">)</span>
</code></pre></div></div>
<p>  socket 함수를 통해 객체를 생성하고, 객체 주소를 변수 sock에 저장한다.<br />
  arg1: 소켓의 Address Family를 정의한다.<br />
  arg2: 소켓의 타입을 정의한다.<br />
  arg3: 소켓의 프로토콜을 정의한다.<br />
<br />
<!-- 소켓 옵션 설정 --></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sock</span><span class="p">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div></div>
<p>  setsockopt 함수를 통해 소켓의 옵션을 설정할 수 있다.<br />
<br />
<!-- 프로세스와 소켓 바인딩 --></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sock</span><span class="p">.</span><span class="n">bind</span><span class="p">((</span><span class="o">&lt;</span><span class="n">IP</span> <span class="n">addr</span><span class="o">&gt;</span><span class="p">:</span><span class="nb">str</span><span class="p">,</span> <span class="o">&lt;</span><span class="n">port</span><span class="o">&gt;</span><span class="p">:</span><span class="nb">int</span><span class="p">):</span><span class="nb">tuple</span><span class="p">)</span>
</code></pre></div></div>
<p>  서버에서 bind 함수를 통해 자신의 IP 주소와 Port 번호를 바인딩(할당받고 해당 객체로 통신)한다.<br />
<br />
<!-- 서버에서 LISTEN 상태로 변경 --></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sock</span><span class="p">.</span><span class="n">listen</span><span class="p">(</span><span class="n">arg</span><span class="p">:</span><span class="nb">int</span><span class="p">)</span>
</code></pre></div></div>
<p>  listen 함수를 통해 서버의 상태가 LISTEN으로 변한다. 해당 소켓은 arg 횟수만큼 연결할 수 있다.<br />
<br />
<!-- 서버에서 연결 확립 --></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">child</span><span class="p">,</span> <span class="n">addr</span> <span class="o">=</span> <span class="n">sock</span><span class="p">.</span><span class="n">accept</span><span class="p">()</span>
</code></pre></div></div>
<p>  accept 함수를 통해 클라이언트와 3WHS(3-Way Handshaking)을 수행한다. accept 함수는 sock을 Fork해서 만들어진 소켓과 클라이언트 소켓주소를 반환한다.<br />
<br />
<!-- 서버에서 데이터 수신 --></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="n">child</span><span class="p">.</span><span class="n">recv</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
</code></pre></div></div>
<p>  recv 함수로 소켓을 통해 data를 전송받는다. arg는 받을 수 있는 최대 버퍼 크기이다.<br />
<br />
<!-- 서버에서 데이터 송신 --></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">child</span><span class="p">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</code></pre></div></div>
<p>  sendall 함수로 소켓을 통해 message를 전송한다.<br />
<br />
<!-- 연결 끊기 --></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">child</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
<span class="n">sock</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
</code></pre></div></div>
<p>  소켓 객체를 OS에 반환한다</p>

<hr />

<h4 id="주의사항">주의사항</h4>
<p>※ 연결을 끊을 때 <strong>부모 객체부터 제거하면 Fork된 소켓은 고아 프로세스</strong>가 된다. 그러므로 <strong>자식 소켓부터 제거</strong>해야 한다<br />
※ 파이썬의 경우 연결을 close 함수를 사용하여 끊지 않아도 <strong>객체가 소멸되면 연결을 끊기므로 주의</strong>하여야 한다
<br /><br /></p>

<hr />

:ET